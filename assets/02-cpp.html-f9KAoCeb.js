import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as e,a as n,o as l}from"./app-BEs1qzOr.js";const t="/ClBlogs/assets/pages/cpp/02-tinyraytracer.svg",p={};function r(h,s){return l(),a("div",null,[e(" more "),s[0]||(s[0]=n(`<p>在 C++ 开发中，性能优化是一个绕不开的关键环节，但受限于硬件、复杂的代码逻辑等多方面的影响，很多情况下我们无法仅靠感觉进行猜测和优化。</p><p>虽然说 <strong>过早的优化是万恶之源</strong>，但当性能问题真正出现时，我们必须有能力精准地定位它，本节我们以一个开源项目 <a href="https://github.com/ssloy/tinyraytracer" target="_blank" rel="noopener noreferrer">tinyraytracer</a> 为例进行分析，介绍几款比较常用的性能分析工具。</p><h2 id="gprof" tabindex="-1"><a class="header-anchor" href="#gprof"><span>Gprof</span></a></h2><p><code>gprof</code> 是 GNU Binutils 工具集自带的一款经典的性能分析（Profiling）工具，它通过在程序中 <strong>插桩</strong> 来收集运行时的信息，能够生成函数级别的性能报告，包括每个函数的调用次数、执行耗时以及函数间的调用关系图。</p><h3 id="报告生成" tabindex="-1"><a class="header-anchor" href="#报告生成"><span>报告生成</span></a></h3><p>以下是使用 <code>gprof</code> 进行性能分析的标准流程，使用此工具时都可以仿照此流程。</p><p>首先，为了使 <code>gprof</code> 能够收集数据，必须在编译和链接阶段都添加 <code>-pg</code> 标志。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ..</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -DCMAKE_CXX_FLAGS=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;-pg&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>添加标志后，正常编译项目并运行生成的可执行文件。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 构建</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ninja</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 运行</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./tinyraytracer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序正常执行完毕后，将在当前工作目录下生成一个名为 <code>gmon.out</code> 的文件，其中包含了原始的性能分析数据，我们可以使用 <code>gprof</code> 命令解析 <code>gmon.out</code> 文件，并将结果重定向到文本文件以便查阅。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gprof</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./tinyraytracer</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> gmon.out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">gprof.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>至此，一份完整的性能分析报告 <code>gprof.txt</code> 就已生成。</p><h3 id="报告分析" tabindex="-1"><a class="header-anchor" href="#报告分析"><span>报告分析</span></a></h3><p><code>gprof</code> 的报告主要包含两部分核心内容：<strong>扁平性能分析（Flat Profile）</strong> 和 <strong>调用图（Call Graph）</strong>。</p><h4 id="扁平性能分析" tabindex="-1"><a class="header-anchor" href="#扁平性能分析"><span>扁平性能分析</span></a></h4><p>这部分按函数自身消耗的 CPU 时间降序排列，是定位性能热点的首要依据。</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>Flat profile:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Each sample counts as 0.01 seconds.</span></span>
<span class="line"><span>  %   cumulative   self              self     total</span></span>
<span class="line"><span> time   seconds   seconds    calls  ns/call  ns/call  name</span></span>
<span class="line"><span> 57.20      0.24     0.24   831826   288.80   288.80  scene_intersect(vec3 const&amp;, vec3 const&amp;)</span></span>
<span class="line"><span> 35.75      0.39     0.15                             cast_ray(vec3 const&amp;, vec3 const&amp;, int)</span></span>
<span class="line"><span>  4.77      0.41     0.02   151140   132.46   132.46  refract(vec3 const&amp;, vec3 const&amp;, float, float)</span></span>
<span class="line"><span>  2.38      0.42     0.01                             main</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>各个名词的含义其实在这个文件中都有介绍，此处我们简单介绍一下：</p><ul><li><code>% time</code>: 函数自身消耗的 CPU 时间占总时间的百分比，不包含其调用的子函数的耗时。</li><li><code>cumulative seconds</code>: 从程序开始累计执行了多长时间。</li><li><code>self seconds</code>: 函数自身的执行耗时多少秒，不含子函数。</li><li><code>calls</code>: 函数被调用的总次数。</li><li><code>self ns/call</code>: 平均每次调用的自身耗时。</li><li><code>total ns/call</code>: 平均每次调用的总耗时，包含子函数。</li><li><code>name</code>: 函数符号。</li></ul><p>根据报告，<code>scene_intersect</code> 函数自身消耗了 <strong>57.20%</strong> 的执行时间，总共执行了 <strong>831826</strong> 次，因此此函数只要有一点优化，对整个程序的优化都是巨大的。</p><h4 id="调用图" tabindex="-1"><a class="header-anchor" href="#调用图"><span>调用图</span></a></h4><p>这部分展示了函数之间详细的调用关系链，能帮助我们理解一个函数的耗时是由自身产生，还是由它调用的其他函数产生。</p><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-txt"><span class="line"><span>index % time    self  children    called     name</span></span>
<span class="line"><span>                              285752             cast_ray(vec3 const&amp;, vec3 const&amp;, int) [1]</span></span>
<span class="line"><span>[1]     97.6    0.15    0.26       0+285752  cast_ray(vec3 const&amp;, vec3 const&amp;, int) [1]</span></span>
<span class="line"><span>                0.24    0.00  831826/831826      scene_intersect(vec3 const&amp;, vec3 const&amp;) [2]</span></span>
<span class="line"><span>                0.02    0.00  151140/151140      refract(vec3 const&amp;, vec3 const&amp;, float, float) [3]</span></span>
<span class="line"><span>                              285752             cast_ray(vec3 const&amp;, vec3 const&amp;, int) [1]</span></span>
<span class="line"><span>-----------------------------------------------</span></span>
<span class="line"><span>                0.24    0.00  831826/831826      cast_ray(vec3 const&amp;, vec3 const&amp;, int) [1]</span></span>
<span class="line"><span>[2]     57.1    0.24    0.00  831826         scene_intersect(vec3 const&amp;, vec3 const&amp;) [2]</span></span>
<span class="line"><span>-----------------------------------------------</span></span>
<span class="line"><span>                               71709             refract(vec3 const&amp;, vec3 const&amp;, float, float) [3]</span></span>
<span class="line"><span>                0.02    0.00  151140/151140      cast_ray(vec3 const&amp;, vec3 const&amp;, int) [1]</span></span>
<span class="line"><span>[3]      4.8    0.02    0.00  151140+71709   refract(vec3 const&amp;, vec3 const&amp;, float, float) [3]</span></span>
<span class="line"><span>                               71709             refract(vec3 const&amp;, vec3 const&amp;, float, float) [3]</span></span>
<span class="line"><span>-----------------------------------------------</span></span>
<span class="line"><span>                                                 &lt;spontaneous&gt;</span></span>
<span class="line"><span>[4]      2.4    0.01    0.00                 main [4]</span></span>
<span class="line"><span>-----------------------------------------------</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们先来理解它的结构：</p><ul><li><code>[index]</code> 是每个核心函数的唯一编号，带 index 的那一行是核心函数。</li><li>核心函数 <strong>上方</strong> 的函数，是调用它的父函数。</li><li>核心函数 <strong>下方</strong> 的函数，是它调用的子函数。</li></ul><p>因此这个部分我们既可以看到调用耗时，还可以看到调用路径，以此判断是否存在递归等现象。</p><p>在本调用图中，我们可以清晰地看到性能热点路径：<code>main</code> -&gt; <code>cast_ray</code> -&gt; <code>scene_intersect</code>。虽然 <code>cast_ray</code> 耗时最长，但它的时间主要花在了调用 <code>scene_intersect</code> 上，因此，<code>scene_intersect</code> 函数是整个程序最核心的性能瓶颈，是优化的首要目标。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>这个方案使用上非常简单，仅需在编译时添加 <code>-pg</code> 标志，并通过简单命令即可生成报告，提供的信息还是很多的，进行初步分析完全足够。</p><p>但是由于它的插桩采样原理，对于 <strong>执行时间极短的函数、动态库的函数、子线程的函数</strong> 都可能无法追踪分析，局限性也是很大。</p><p>因此 gprof 更多的是对 <strong>单线程、计算密集型</strong> 的应用程序进行初步的性能分析，要想有更多的功能还是得采用其他策略。</p><h2 id="perf-flamegraph" tabindex="-1"><a class="header-anchor" href="#perf-flamegraph"><span>Perf &amp; FlameGraph</span></a></h2><p>gprof 只能算是玩具，更多情况下我们会使用 <code>perf</code> 进行分析，它直接构建于 Linux 内核的性能计数器（PMU）之上，因此开销极低，它不止能提供用户态的调用，还可以分析内核、硬件级别的使用情况。</p><p>而 <strong>火焰图（Flame Graph）</strong> 则是一种性能可视化工具，它能将 <code>perf</code> 采集到的海量调用栈数据，转换为 svg 这样的可视化图，方便进行分析。</p><h3 id="火焰图生成" tabindex="-1"><a class="header-anchor" href="#火焰图生成"><span>火焰图生成</span></a></h3><p>生成火焰图需要两步：首先使用 <code>perf</code> 采集数据，然后使用 <a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener noreferrer">FlameGraph</a> 项目提供的脚本将数据转换成火焰图。</p><p>首先先装一下这两个东西：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 安装 perf</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pacman</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -S</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> perf</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 下载火焰图工具集</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> clone</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> https://github.com/brendangregg/FlameGraph.git</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在编译时不需要 <code>-pg</code> 标志，但为了能清晰地看到函数名而不是一堆地址，我们需要加入调试信息 <code>-g</code>。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 假设已回到 build 目录</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ..</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -DCMAKE_CXX_FLAGS=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;-g&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ninja</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，使用 <code>perf record</code> 命令来运行程序并采集性能数据。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># -F 99: 指定采样频率为 99Hz</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># -g: 表示记录调用图</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">perf</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> record</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -F</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 99</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -g</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./tinyraytracer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结束后，当前目录会生成一个 <code>perf.data</code> 文件，这就是 <code>perf</code> 采集到的原始性能数据。我们可以通过 <code>perf report</code> 命令在终端中交互式地查看一个简化版的分析结果，它和 <code>gprof</code> 的扁平分析有些类似，可以自己看一下。</p><p>接下来就是火焰图的生成流程，这需要借助 FlameGraph 项目中的两个核心脚本：<code>stackcollapse-perf.pl</code> 和 <code>flamegraph.pl</code>。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 分析并折叠调用栈</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> perf</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">.</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">./FlameGraph/stackcollapse-perf.pl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">out.perf-folded</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 生成 SVG 火焰图</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">.</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">./FlameGraph/flamegraph.pl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> out.perf-folded</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">perf.svg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们得到了一张名为 <code>perf.svg</code> 的图片，也是我们期望看到的火焰图。</p><h3 id="火焰图分析" tabindex="-1"><a class="header-anchor" href="#火焰图分析"><span>火焰图分析</span></a></h3><p>火焰图看起来像一座由许多矩形“火焰”组成的山脉，非常直观：</p><figure><img src="`+t+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>Y 轴</strong>：代表了 <strong>调用栈的深度</strong>。顶部的函数是正在执行的函数，它下方的函数是调用它的父函数。</li><li><strong>X 轴</strong>：代表了 <strong>样本数量</strong>。一个矩形的宽度越宽，就表示它（以及它调用的所有子函数）在采样中出现的次数越多，也就是执行耗时越长。<strong>因此，寻找性能瓶颈，就是寻找那些最宽的火焰山顶</strong>。</li></ul><p>通过分析火焰图，我们可以轻易地发现，<code>scene_intersect</code> 函数对应的矩形最宽，所以它最耗时。这与我们之前用 <code>gprof</code> 得到的结论完全一致，火焰图的优势在于，它能更清晰地展示出从 <code>main</code> 函数到性能热点函数的完整调用路径和耗时分布，如果调用链非常复杂，火焰图的优势会更加明显。</p><h3 id="服务器分析" tabindex="-1"><a class="header-anchor" href="#服务器分析"><span>服务器分析</span></a></h3><p>对于像 Web 服务器、数据库或后台服务这样长期运行（long-running）的程序，我们不可能等到它退出再分析，<code>perf</code> 对此提供了完美的支持，我们可以随时附加到指定的进程上进行采样。</p><p>首先需要获取正在运行的服务器程序的进程 ID（PID），可以使用 <code>pgrep</code> 或 <code>ps</code> 命令：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pgrep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> server</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 或者</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ps</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> aux</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> server</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取到 PID 后，使用 <code>perf record</code> 的 <code>-p</code> 选项来指定要分析的进程，我们此处采用定时采样的方案：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 假设 PID 是 12345，我们采样 30 秒</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> perf</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> record</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -F</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 99</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -g</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 12345</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sleep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候可以用一些压测工具进行测试，结束后会生成 <code>perf.data</code> 文件，后续生成火焰图的步骤与之前保持一致即可。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><p>perf + 火焰图的方式更适合绝大多数场景，源于它对内核 + 用户的追踪能力，且由于它的非侵入式采样，非常适合用于生产环境或对性能敏感的应用，最主要的是最后的火焰图，让我们可以一眼看出瓶颈所在，也可以在不同时间段截取火焰图，以对比分析。</p><h2 id="valgrind-kcachegrind" tabindex="-1"><a class="header-anchor" href="#valgrind-kcachegrind"><span>Valgrind &amp; KCachegrind</span></a></h2><p><code>Valgrind</code> 主要用于进行微观分析，它是一个非常强大的动态分析框架，包含多种工具，其中用于性能分析的是 <code>callgrind</code>。</p><p>与 <code>perf</code> 基于采样的原理不同，<code>callgrind</code> 通过 <strong>动态二进制插桩</strong> 技术，在程序运行时监控并记录每一条指令的执行信息，因此它能提供极其详尽的数据，比如每个函数确切的调用次数、执行的指令数等，而不仅仅是基于概率的估算。</p><p>当然，这种精确性是有代价的，<code>Valgrind</code> 会让你的程序运行得非常非常慢（通常会慢 10-100 倍），因此它不适合分析整个大型项目或对实时性要求高的服务，而更适合对已经定位到的核心模块或函数进行深入、细致的分析。</p><p><code>KCachegrind</code> (在某些系统上叫 <code>QCachegrind</code>) 则是 <code>callgrind</code> 输出文件的可视化前端，它能以非常友好的界面展示所有收集到的数据。</p><h3 id="数据生成" tabindex="-1"><a class="header-anchor" href="#数据生成"><span>数据生成</span></a></h3><p>如果没有安装的话，可以搜一下自己的平台如何安装，在 arch 上直接安装即可：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pacman</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -S</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> valgrind</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> kcachegrind</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>运行 <code>callgrind</code> 无需特殊编译参数，但为了看到清晰的函数名，保留 <code>-g</code> 调试信息依然是比较推荐的。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 生成构建文件</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ..</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -DCMAKE_CXX_FLAGS=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;-g&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 然后正常编译和运行即可</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># --tool=callgrind: 指定使用 callgrind 工具</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># --dump-instr=yes: 收集指令级别的数据</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># --collect-jumps=yes: 收集跳转指令数据，用于构建更精确的控制流图</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valgrind</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --tool=callgrind</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --dump-instr=yes</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --collect-jumps=yes</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./tinyraytracer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序会以极慢的速度运行，结束后会在当前目录生成一个名为 <code>callgrind.out.PID</code> 的文件（PID 是进程号）。</p><h3 id="数据分析" tabindex="-1"><a class="header-anchor" href="#数据分析"><span>数据分析</span></a></h3><p>直接使用 <code>kcachegrind</code> 命令打开上一步生成的文件：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">kcachegrind</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> callgrind.out.PID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>KCachegrind 的界面非常强大，主要关注如下几个数据：</p><ul><li><p><strong>Flat Profile</strong>: 左侧面板默认显示所有函数的列表，可以按多种指标排序。</p><ul><li><strong>Incl. (Inclusive)</strong>: 包含所有成本，即该函数以及它调用的所有子函数的总成本，类似于火焰图的宽度。</li><li><strong>Self (Self)</strong>: 自身成本，即仅该函数自身执行的成本，不包含子函数。</li></ul></li><li><p><strong>右侧面板</strong>: 选中一个函数后，右侧会出来该函数的很多选项：</p><ul><li><strong>Source Code</strong>: KCachegrind 可以将性能数据标注到每一行源代码或汇编指令上，让你精确地看到哪一行代码消耗了最多的资源。</li><li><strong>callers</strong>：该函数各个调用子函数的占比情况。</li></ul></li></ul><p>通过 KCachegrind，我们可以再次确认 <code>scene_intersect</code> 是性能瓶颈，并且能得到它被精确调用了多少次，执行了多少条指令，这些都是 <code>perf</code> 无法提供的精确数据。</p><h3 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h3><p><code>Valgrind</code> 提供的是极致精确的性能数据，我们可以用 <code>perf</code> 定位到某个可疑的复杂函数，然后使用 <code>callgrind</code> 对其进行精细解剖，找出其中最耗资源的代码行，但由于其巨大的性能开销，切记 <strong>不要用它来分析整个系统或大型应用的启动过程</strong>。</p><p>本节代码详见<a href="https://github.com/KBchulan/ClBlogs-Src/blob/main/blogs-main/cpp/02-performance-analysis/main.cc" target="_blank" rel="noopener noreferrer">此处</a>。</p>`,81))])}const o=i(p,[["render",r]]),k=JSON.parse('{"path":"/blogs-main/cpp/02-cpp.html","title":"02 性能分析工具","lang":"zh-CN","frontmatter":{"title":"02 性能分析工具","article":true,"order":2,"star":false,"category":["语言"],"tag":["cpp"],"date":"2025-09-02T00:00:00.000Z","description":"cpp 中常见的性能分析工具","footer":"Always coding, always learning","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"02 性能分析工具\\",\\"image\\":[\\"https://kbchulan.github.io/ClBlogs/ClBlogs/assets/pages/cpp/02-tinyraytracer.svg\\"],\\"datePublished\\":\\"2025-09-02T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-03T06:46:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KBchulan\\",\\"url\\":\\"https://kbchulan.github.io/ClBlogs/\\"}]}"],["meta",{"property":"og:url","content":"https://kbchulan.github.io/ClBlogs/ClBlogs/blogs-main/cpp/02-cpp.html"}],["meta",{"property":"og:site_name","content":"KBchulan的博客"}],["meta",{"property":"og:title","content":"02 性能分析工具"}],["meta",{"property":"og:description","content":"cpp 中常见的性能分析工具"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://kbchulan.github.io/ClBlogs/ClBlogs/assets/pages/cpp/02-tinyraytracer.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-03T06:46:39.000Z"}],["meta",{"property":"article:tag","content":"cpp"}],["meta",{"property":"article:published_time","content":"2025-09-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-03T06:46:39.000Z"}]]},"git":{"createdTime":1752823439000,"updatedTime":1756881999000,"contributors":[{"name":"KBchulan","username":"KBchulan","email":"18737519552@163.com","commits":4,"url":"https://github.com/KBchulan"}]},"readingTime":{"minutes":10.46,"words":3139},"filePathRelative":"blogs-main/cpp/02-cpp.md","excerpt":""}');export{o as comp,k as data};
