import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as t,a as n,o as e}from"./app-ChTCY9cf.js";const p={};function l(h,s){return e(),a("div",null,[t(" more "),s[0]||(s[0]=n(`<h1 id="_17-为什么你的测试不够好" tabindex="-1"><a class="header-anchor" href="#_17-为什么你的测试不够好"><span>17 为什么你的测试不够好？</span></a></h1><p>关于测试，我们前面讲了很多，比如：开发者应该写测试；要写可测的代码；要想做好 TDD，先要做好任务分解，我还带你进行了实战操作，完整地分解了一个任务。</p><p>但有一个关于测试的重要话题，我们始终还没聊，那就是测试应该写成什么样。今天我就来说说怎么把测试写好。</p><p>你或许会说，这很简单啊，前面不都讲过了吗？不就是用测试框架写代码吗？其实，理论上来说，还真应该就是这么简单，但现实情况却往往相反。我看到过很多团队在测试上出现过各种各样的问题，比如：</p><ul><li>测试不稳定，这次能过，下次过不了；</li><li>有时候是一个测试要测的东西很简单，测试周边的依赖很多，搭建环境就需要很长的时间；</li><li>这个测试要运行，必须等到另外一个测试运行结束；</li><li>……</li></ul><p>如果你也在工作中遇到过类似的问题，那你理解的写测试和我理解的写测试可能不是一回事，那问题出在哪呢？</p><p>为什么你的测试不够好呢？</p><p><strong>主要是因为这些测试不够简单。只有将复杂的测试拆分成简单的测试，测试才有可能做好。</strong></p><h2 id="简单的测试" tabindex="-1"><a class="header-anchor" href="#简单的测试"><span>简单的测试</span></a></h2><p>测试为什么要简单呢？有一个很有趣的逻辑，不知道你想没想过，测试的作用是什么？显然，它是用来保证代码的正确性。随之而来的一个问题是，谁来保证测试的正确性？</p><p>许多人第一次面对这个问题，可能会一下子懵住，但脑子里很快便会出现一个答案：测试。但是，你看有人给测试写测试吗？肯定没有。因为一旦这么做，这个问题会随即上升，谁来保证那个测试的正确性呢？你总不能无限递归地给测试写测试吧。</p><p>既然无法用写程序的方式保证测试的正确性，我们只有一个办法：<strong>把测试写简单，简单到一目了然，不需要证明它的正确性。</strong> 所以，如果你见到哪个测试写得很复杂，它一定不是一个好的测试。</p><p>既然说测试应该简单，我们就来看看一个简单的测试应该是什么样子。下面我给出一个简单的例子，你可以看一下。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Test</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> should_extract_HTTP_method_from_HTTP_request</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 前置准备</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  request </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> mock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">HttpRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  when</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">request</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thenReturn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">HttpMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">GET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  HttpMethodExtractor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> extractor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> HttpMethodExtractor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  HttpMethod</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> method </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> extractor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">extract</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(request);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 断言</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assertThat</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> is</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">HttpMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">GET</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 清理</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个测试很简单，从一个 HTTP 请求中提取出 HTTP 方法。</p><p>我把这段代码分成了四段，分别是<strong>前置准备、执行、断言和清理</strong>，这也是一般测试要具备的四段。</p><ul><li>这几段的核心是中间的执行部分，它就是测试的目标，但实际上，它往往也是最短小的，一般就是一行代码调用。其他的部分都是围绕它展开的，在这里就是调用 HTTP 方法提取器提取 HTTP 方法。</li><li>前置准备，就是准备执行部分所需的依赖。比如，一个类所依赖的组件，或是调用方法所需要的参数。在这个测试里面，我们准备了一个 HTTP 请求，设置了它的方法是一个 GET 方法，这里面还用到了之前提到的 Mock 框架，因为完整地设置一个 HTTP 请求很麻烦，而且与这个测试也没什么关系。</li><li>断言是我们的预期，就是这段代码执行出来怎么算是对的。这里我们判断了提取出来的方法是否是 GET 方法。另外补充一点，断言并不仅仅是 assert，如果你用 Mock 框架的话，用以校验 mock 对象行为的 verify 也是一种断言。</li><li>清理是一个可能会有的部分，如果你的测试用到任何资源，都可以在这里释放掉。不过，如果你利用好现有的测试基础设施（比如，JUnit 的 Rule），遵循好测试规范的话，很多情况下，这个部分就会省掉了。</li></ul><p>怎么样，看着很简单吧，是不是符合我前面所说的不证自明呢？</p><h2 id="测试的坏味道" tabindex="-1"><a class="header-anchor" href="#测试的坏味道"><span>测试的坏味道</span></a></h2><p>有了对测试结构的了解，我们再来说说常见的测试“坏味道”。</p><p>首先是执行部分。不知道你有没有注意到，前面我提到执行部分时用了一个说法，一行代码调用。是的，第一个“坏味道”就来自这里。</p><p>很多人总想在一个测试里做很多的事情，比如，出现了几个不同方法的调用。请问，你的代码到底是在测试谁呢？</p><p><strong>这个测试一旦出错，就需要把所有相关的几个方法都查看一遍，这无疑是增加了工作的复杂度。</strong></p><p>也许你会问，那我有好几个方法要测试，该怎么办呢？很简单，多写几个测试就好了。</p><p>另一个典型“坏味道”的高发区是在断言上，请记住，<strong>测试一定要有断言。</strong> 没有断言的测试，是没有意义的，就像你说自己是世界冠军，总得比个赛吧！</p><p>我见过不少人写了不少测试，但测试运行几乎从来就不会错。出于好奇，我打开代码一看，没有断言。</p><p>没有断言当然就不会错了，写测试的同事还很委屈地说，测试不好写，而且，他已经验证了这段代码是对的。就像我前面讲过的，测试不好写，往往是设计的问题，应该调整的是设计，而不是在测试这里做妥协。</p><p>还有一种常见的“坏味道”：复杂。最典型的场景是，当你看到测试代码里出现各种判断和循环语句，基本上这个测试就有问题了。</p><p>举个例子，测试一个函数，你的断言写在一堆 if 语句中，美其名曰，根据条件执行。还是前面提到的那个观点，你怎么保证这个测试函数写的是对的？除非你用调试的手段，否则，你都无法判断你的条件分支是否执行到了。</p><p>你或许会疑问，我有一大堆不同的数据要测，不用循环不用判断，我怎么办呢？<strong>你真正应该做的是，多写几个测试，每个测试覆盖一种场景。</strong></p><h2 id="一段旅程-a-trip" tabindex="-1"><a class="header-anchor" href="#一段旅程-a-trip"><span>一段旅程（A-TRIP）</span></a></h2><p>怎么样的测试算是好的测试呢？有人做了一个总结 A-TRIP，这是五个单词的缩写，分别是</p><ul><li>Automatic，自动化；</li><li>Thorough，全面的；</li><li>Repeatable，可重复的；</li><li>Independent，独立的；</li><li>Professional，专业的。</li></ul><p>下面，我们看看这几个单词分别代表什么意思。</p><p><strong>Automatic，自动化。</strong> 有了前面关于自动化测试的铺垫，这可能最好理解，就是把测试尽可能交给机器执行，人工参与的部分越少越好。</p><p>这也是我们在前面说，测试一定要有断言的原因，因为一个测试只有在有断言的情况下，机器才能自动地判断测试是否成功。</p><p><strong>Thorough，全面，应该尽可能用测试覆盖各种场景。</strong> 理解这一点有两个角度。一个是在写代码之前，要考虑各种场景：正常的、异常的、各种边界条件；另一个角度是，写完代码之后，我们要看测试是否覆盖了所有的代码和所有的分支，这就是各种测试覆盖率工具发挥作用的场景了。</p><p>当然，你想做到全面，并非易事，如果你的团队在补测试，一种办法是让测试覆盖率逐步提升。</p><p><strong>Repeatable，可重复的。</strong> 这里面有两个角度：某一个测试反复运行，结果应该是一样的，这说的是，每一个测试本身都不应该依赖于任何不在控制之下的环境。如果有，怎么办，想办法。</p><p>有的测试会依赖数据库，那就在执行完测试之后，将数据库环境恢复，像 Spring 的测试框架就提供了测试数据库回滚的能力。如果你的测试反复运行，不能产生相同的结果，要么是代码有问题，要么是测试有问题。</p><p>理解可重复性，还有一个角度，一堆测试反复运行，结果应该是一样的。这说明测试和测试之间没有任何依赖，这也是我们接下来要说的测试的另外一个特点。</p><p><strong>Independent，独立的。</strong> 测试和测试之间不应该有任何依赖，什么叫有依赖？比如，如果测试依赖于外部数据库或是第三方服务，测试 A 在运行时在数据库里写了一些值，测试 B 要用到数据库里的这些值，测试 B 必须在测试 A 之后运行，这就叫有依赖。</p><p>我们不能假设测试是按照编写顺序运行的。比如，有时为了加快测试运行速度，我们会将测试并行起来，在这种情况下，顺序是完全无法保证的。如果测试之间有依赖，就有可能出现各种问题。</p><p>减少外部依赖可以用 mock，实在要依赖，每个测试自己负责前置准备和后续清理。如果多个测试都有同样的准备和清理呢？那不就是 setup 和 teardown 发挥作用的地方吗？测试基础设施早就为我们做好了准备。</p><p><strong>Professional，专业的。</strong> 这一点是很多人观念中缺失的，测试代码，也是代码，也要按照代码的标准去维护。这就意味着你的测试代码也要写得清晰，比如：良好的命名，把函数写小，要重构，甚至要抽象出测试的基础库，在 Web 测试中常见的 PageObject 模式，就是这种理念的延伸。</p><p>看了这点，你或许会想，你说的东西有点道理，但我的代码那么复杂，测试路径非常多，我怎么能够让自己的测试做到满足这些要求呢？</p><p>我必须强调一个之前讲测试驱动开发强调过的观点：<strong>编写可测试的代码。</strong> 很多人写不好测试，或者觉得测试难写，关键就在于，你始终是站在写代码的视角，而不是写测试的视角。如果你都不重视测试，不给测试留好空间，测试怎么能做好呢？</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻"><span>总结时刻</span></a></h2><p>测试是一个说起来很简单，但很不容易写好的东西。在实际工作中，很多人都会遇到关于测试的各种各样问题。之所以出现问题，主要是因为这些测试写得太复杂了。测试一旦复杂了，我们就很难保证测试的正确性，何谈用测试保证代码的正确性。</p><p>我给你讲了测试的基本结构：前置准备、执行、断言和清理，还介绍了一些常见的测试“坏味道”：做了太多事的测试，没有断言的测试，还有一种看一眼就知道有问题的“坏味道”，测试里有判断语句。</p><p>怎么衡量测试是否做好了呢？有一个标准：A-TRIP，这是五个单词的缩写，分别是Automatic（自动化）、Thorough（全面）、Repeatable（可重复的）、Independent（独立的）和 Professional（专业的）。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>要想写好测试，就要写简单的测试。</strong></p><p>最后，我想请你分享一下，经过最近持续对测试的讲解，你对测试有了哪些与之前不同的理解呢？欢迎在留言区写下你的想法。</p>`,53))])}const d=i(p,[["render",l]]),o=JSON.parse('{"path":"/pages-other/work-method/17-work-method.html","title":"17 为什么你的测试不够好？","lang":"zh-CN","frontmatter":{"title":"17 为什么你的测试不够好？","article":true,"order":17,"star":false,"category":["摘录"],"tag":["程序员工作法"],"date":"2025-06-18T00:00:00.000Z","footer":"Always coding, always learning","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"17 为什么你的测试不够好？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-18T05:18:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KBchulan\\",\\"url\\":\\"https://kbchulan.github.io/ClBlogs/\\"}]}"],["meta",{"property":"og:url","content":"https://kbchulan.github.io/ClBlogs/ClBlogs/pages-other/work-method/17-work-method.html"}],["meta",{"property":"og:site_name","content":"KBchulan的博客"}],["meta",{"property":"og:title","content":"17 为什么你的测试不够好？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-18T05:18:06.000Z"}],["meta",{"property":"article:tag","content":"程序员工作法"}],["meta",{"property":"article:published_time","content":"2025-06-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-18T05:18:06.000Z"}]]},"git":{"createdTime":1750223886000,"updatedTime":1750223886000,"contributors":[{"name":"KBchulan","username":"KBchulan","email":"145010602+KBchulan@users.noreply.github.com","commits":1,"url":"https://github.com/KBchulan"}]},"readingTime":{"minutes":10.37,"words":3111},"filePathRelative":"pages-other/work-method/17-work-method.md","excerpt":""}');export{d as comp,o as data};
