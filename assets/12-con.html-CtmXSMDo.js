import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as r,a as o,o as n}from"./app-DQGRINgw.js";const p={};function s(i,t){return n(),a("div",null,[r(" more "),t[0]||(t[0]=o('<h1 id="_12-无锁的四种设计原则" tabindex="-1"><a class="header-anchor" href="#_12-无锁的四种设计原则"><span>12 无锁的四种设计原则</span></a></h1><p>前面我们实现过了无锁队列和无锁栈，其实可以发现它们不管是优化还是实现上，好像是比较相似的，这也引出了本节要介绍的主题 —— <strong>无锁并发的四种设计原则</strong>。</p><h2 id="内存序" tabindex="-1"><a class="header-anchor" href="#内存序"><span>内存序</span></a></h2><p>俗话说: <strong>过早的优化是万恶之源</strong>，在前面我们提到了 <code>std::memory_order_seq_cst</code> 会让所有线程都看到一个公认的全局总排序，因此它的性能其实是不太好的，但这个不太好也只是局限于与其他几种内存序相比，它其实还是比有锁结构更快的，但它可以让我们放心的开发，而不用担心可见性导致的问题，从这一点看，这个内存序是更利好开发的。</p><p>因此在实际设计中，更建议的是 <strong>先不要考虑内存序的优化，先全部使用默认的内存序，当我们所有操作都正常工作后，再选择性优化内存序</strong>。</p><p>原因在于我们通常只有先完全了解代码全貌，认清哪些代码操作核心数据结构，才可以确定放宽哪些操作的内存次序约束，否则，事情就会很棘手。</p><p>即便代码在测试过程中正常工作，也无法保证在生产环境下代码依然如此，所以，仅仅测试代码的运行并不足够，除非我们能够采用测试工具（假如真的存在），系统化地核查线程访问内存次序的全部可能的组合，验证它们是否与指定的内存次序约束保持一致，否则默认内存序会是更好的选择。</p><h2 id="内存管控" tabindex="-1"><a class="header-anchor" href="#内存管控"><span>内存管控</span></a></h2><p>无锁设计中如何安全回收内存也是一大难题，从设计上来说，我们会有两个选择:</p><ol><li><p>预先分配内存，随后程序退出后再集中回收</p></li><li><p>动态分配内存，并动态回收</p></li></ol><hr><p>这两种方案各有优劣，对于前者，也是我们这两个结构的选择，它的好处显而易见: 回收安全，可以确保所有内存被回收，使用上效率也很高，毕竟无需频繁操作堆内存，而是预先在堆区分配固定大小。</p><p>但这也是它的不足之处: 固定大小导致它无法扩容，导致它容易出现两个极端，太够用或不够用，前者会导致一部分资源浪费，后者我们做了优化，不需要考虑，除此以外，固定内存的使用极易出现 ABA 问题，需要引入其他方案解决。</p><p>因此，如果采用这种方案，就需要在 <strong>容量和 ABA 问题</strong> 设计上下功夫。</p><hr><p>而对于第二种选择，相比于第一种选择，它的好处在于可以按需分配内存，不会造成资源浪费，但是相对应的，它的不足之处在于每次都得分配内存，性能不好，且需要考虑内存回收: <strong>只要仍有线程在操作，就不能回收此资源</strong>，但是长期以来会导致大量资源被分配但是没有被回收，针对这种情况，比较主流的三种方案：</p><ul><li>暂缓全部删除对象的动作，等到没有线程访问数据结构的时候，才删除待销毁的对象;</li><li>采用风险指针，以辨识特定对象是否正在被某线程访问;</li><li>就对象进行引用计数，只要外部环境仍正在指涉目标对象，它就不会被删除;</li></ul><p>这三种方案都是为了标记有多少线程正在访问资源，从而确定是否回收。</p><p>如果选择这种方案，就需要在 <strong>内存安全回收</strong> 上下功夫。</p><hr><p>到这里来看，前者除了可能的内存浪费，其余貌似全面碾压后者，因此个人 <strong>更建议使用内存池等预先分配内存的方案</strong>。</p><h2 id="aba问题" tabindex="-1"><a class="header-anchor" href="#aba问题"><span>ABA问题</span></a></h2><p>ABA问题是无锁编程中的一个经典问题，在 CAS 操作中经常遇到，它描述的是这样一种情况：</p><ul><li>线程1读取了某个内存位置的值A</li><li>线程1被抢占，线程2开始执行</li><li>线程2将该内存位置的值从A改为B，然后又改回A</li><li>线程1恢复执行，使用CAS操作检查该内存位置的值仍然是A，于是认为值没有被修改过</li><li>线程1继续执行，但实际上该内存位置的值已经被其他线程修改过了</li></ul><p>ABA问题的本质在于：<strong>仅仅通过比较值是否相等，无法判断该值是否被其他线程修改过</strong>。即使值在表面上没有变化（从A变为A），但背后可能经历了复杂的状态变迁。</p><p>看过上一节的内容，你就会知道，ABA 问题是很严重的，比如无锁栈成的环，再比如，假设我们的值是个指针呢，那我指针地址没变，内容变了是不是照样看不出来，因此 <strong>千万不要觉得 ABA 问题不是问题</strong>。</p><p>解决 ABA 问题的方案也很多，我们说只通过值比较不行，那就多加一个变量，比如 <strong>时间戳或次数戳</strong> 一类的，此时比较时需要比较这两个参数，如果两个操作之间被修改了，那时间戳是不是就变了，CAS 操作就会失败，这样就解决了 ABA 问题，当然也可以参考我们设计无锁队列时引入的序列号机制。</p><p>总结下来就是: <strong>采用递增原子或者 Tagged ptr 操作解决 ABA</strong>。</p><h2 id="cpu-空转" tabindex="-1"><a class="header-anchor" href="#cpu-空转"><span>CPU 空转</span></a></h2><p>在高并发情况下，多个线程对同一个原子变量进行 CAS，一定会有大量操作无效，导致 CPU 空转，白白消耗性能，这种情况下我们可以引入一些退避策略，如指数退避，让失败的线程歇一会，从而减少 CPU 空转。</p><p>到此为止，cpp并发编程的术就已经介绍完了，从基本的线程发起到实现亿级吞吐结构，内容还是非常多的，剩下的就是靠实战积累的经验了，希望都能有所收获。</p>',31))])}const h=e(p,[["render",s]]),d=JSON.parse('{"path":"/blogs-main/concurrent/12-con.html","title":"12 无锁的四种设计原则","lang":"zh-CN","frontmatter":{"title":"12 无锁的四种设计原则","article":true,"order":12,"star":false,"category":["并发"],"tag":["cpp"],"date":"2025-09-22T00:00:00.000Z","description":"总结前面两个结构并引出无锁的四种设计原则","footer":"Always coding, always learning","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"12 无锁的四种设计原则\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-09-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-21T14:00:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KBchulan\\",\\"url\\":\\"https://kbchulan.github.io/ClBlogs/\\"}]}"],["meta",{"property":"og:url","content":"https://kbchulan.github.io/ClBlogs/ClBlogs/blogs-main/concurrent/12-con.html"}],["meta",{"property":"og:site_name","content":"KBchulan的博客"}],["meta",{"property":"og:title","content":"12 无锁的四种设计原则"}],["meta",{"property":"og:description","content":"总结前面两个结构并引出无锁的四种设计原则"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-21T14:00:26.000Z"}],["meta",{"property":"article:tag","content":"cpp"}],["meta",{"property":"article:published_time","content":"2025-09-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-21T14:00:26.000Z"}]]},"git":{"createdTime":1758438789000,"updatedTime":1758463226000,"contributors":[{"name":"KBchulan","username":"KBchulan","email":"18737519552@163.com","commits":2,"url":"https://github.com/KBchulan"}]},"readingTime":{"minutes":5.57,"words":1671},"filePathRelative":"blogs-main/concurrent/12-con.md","excerpt":""}');export{h as comp,d as data};
