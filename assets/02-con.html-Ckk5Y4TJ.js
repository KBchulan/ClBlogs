import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,a as l,o as h}from"./app-C0W3703I.js";const t={};function e(p,s){return h(),a("div",null,[n(" more "),s[0]||(s[0]=l(`<h1 id="_02-线程管控" tabindex="-1"><a class="header-anchor" href="#_02-线程管控"><span>02 线程管控</span></a></h1><p>本节的内容比较简单，会介绍一下 C++ 线程管控，包括移交线程的归属权，线程并发数量控制以及获取线程id等基本操作。</p><h2 id="线程所属权" tabindex="-1"><a class="header-anchor" href="#线程所属权"><span>线程所属权</span></a></h2><p>简单说来：<strong>线程必须被一个东西管控，可以是语言内置的变量、容器等，也可以是系统。</strong></p><p>先来看一个小案例：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func1_err</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 1. 创建线程1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::thread </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thr1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]() -&gt; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 2. 将该线程移交给线程2进行管理，此时 thr1 就空闲了</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::thread thr2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(thr1);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 3. 重新给 thr1 分配一个新线程</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  thr1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]() -&gt; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 4. 把线程2给thr1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  thr1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(thr2);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  thr1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译并运行就可以看到，在第4步触发了 <code>std::terminate()</code>，原因也很简单，第四步时会走线程的移动赋值操作，而看一下源码：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">thread</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">thread</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> __t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">joinable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__terminate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">__t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这下就很清晰了，thr1 还没有被 join 或者 detach，所以肯定会进入 <code>std::terminate()</code>，从而引发崩溃。</p><p>因此修改方案也很简单，只需要在第4步之前调用 <code>thr1.detach()</code> 或 <code>thr1.join()</code> 即可，前者可以把线程交给系统，后者等待该线程结束，都可以确保线程在工作完成前被管控。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::thread </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thr1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]() -&gt; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {});</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::thread thr2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(thr1);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  thr1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]() -&gt; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  thr1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">detach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  thr1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(thr2);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  thr1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结一下，我们的线程构造时会交由一个变量进行管控，此时这个变量会接管线程的生命周期，也是系统中与该线程交互的唯一途径。</p><p>而标准规定中，<strong>不允许存在无管控的线程</strong>，管控权的修改只有两条途径：</p><ul><li>当拥有所有权的变量被销毁，如离开作用域</li><li>当拥有所有权的变量被赋予一个新的线程，如通过移动赋值</li></ul><p>在这两种情况下，如果线程的管控权<strong>没有被移交给其他变量或交给系统</strong>，就会收到严厉的惩罚：<strong>触发 <code>std::terminate()</code>，强制终止程序。</strong></p><p>因此在书写时，如果遇到如上两种情况，要特别注意线程的管控权是否被正确转移，所以选择 <code>std::jthread</code> 是非常好的，可以避免很多 bug。</p><blockquote><p>ps: 这个线程的管控权是不是很类似于 <a href="https://kbchulan.github.io/ClBlogs/blogs-main/rust/05-rust.html#%E6%89%80%E6%9C%89%E6%9D%83%E5%8E%9F%E5%88%99" target="_blank" rel="noopener noreferrer">rust的所有权</a>。</p></blockquote><h2 id="rvo-nrvo" tabindex="-1"><a class="header-anchor" href="#rvo-nrvo"><span>RVO/NRVO</span></a></h2><p>这里补充一个小知识点，也就是 RVO/NRVO 优化，首先来看一段代码：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">thread</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> rvo_use</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]() -&gt; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;RVO thread is running</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> thr1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> rvo_use</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  thr1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们先看一下这个 <code>rvo_use()</code> 相关的，首先请考虑一下，此处都会发生什么构造？</p><p>按照常规语法理解，rvo_use 调用 <strong>有参构造</strong> 返回一个纯右值的 thread 对象，然后通过 <strong>移动构造</strong> 构造 thr1。</p><p>但是实际上编译器会存在一种优化，即 <strong>返回值优化（Return Value Optimization, RVO）</strong>：<strong>它允许编译器在某些情况下直接将函数返回值的构造过程直接在调用者处完成，而不需要进行一次额外的拷贝或移动操作</strong>。</p><p>在这个例子中，会在 <code>func2</code> 的栈空间分配内存，随后直接在该内存处进行构造，因此只会走一次 <strong>有参构造</strong>。</p><p>与之类似的还有一个 <strong>具名返回值优化（Named Return Value Optimization, NRVO）</strong>，和 RVO 一样，下面的代码始终只会走一个 <strong>有参构造</strong>。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">thread</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> nrvo_use</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::thread </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]() -&gt; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;NRVO thread is running</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> thr;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> thr2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> nrvo_use</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  thr2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>值得注意的是：<strong>在c++17及以后，该行为不再是一个优化选项，而是一个语言规则。</strong> 也就是说，这个行为一定会发生。</p><h2 id="线程数量选择" tabindex="-1"><a class="header-anchor" href="#线程数量选择"><span>线程数量选择</span></a></h2><p>一个并发程序应该设置几个线程，这个问题没有所谓的最佳答案，但是有一些经验准则值得参考。</p><p>首先，cpp有一个基准类的函数 <code>std::thread::hardware_concurrency()</code> 可以返回 <strong>逻辑核心的数量</strong>：</p><ul><li>在没有超线程的CPU上，逻辑核心数 = 物理核心数。</li><li>在有超线程的CPU上，逻辑核心数 = 物理核心数 * 2。</li></ul><p>接着，需要考虑具体的应用场景，我们从如下两种情况讨论一下：</p><ul><li><p><strong>CPU密集型任务</strong>：这种任务的特点是需要大量的计算，线程几乎总是在满负荷工作，很少等待，因此应该尽可能减少线程上下文切换开销，这种情况下最好的选择是 <strong>等于逻辑核心数量</strong>。</p></li><li><p><strong>I/O密集型任务</strong>：这种任务的特点是线程大部分时间都在等待外部设备或服务的响应，而不是在进行计算，这种情况下瓶颈在于 I/O 设备，因此线程数可以设置的更多，存在一个被广泛引用的公式：<strong>最佳线程数 = CPU核心数 * (1 + 线程等待时间 / 线程计算时间)</strong>。</p></li></ul><h2 id="识别线程" tabindex="-1"><a class="header-anchor" href="#识别线程"><span>识别线程</span></a></h2><p>我们在开发过程中，会有一个需求，即判断是哪个线程在执行某个任务，因此需要获取当前线程的标识符。</p><p>cpp 为我们内置了一个方法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::thread::id id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">this_thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get_id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Current thread ID: {}</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, id);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，也可以有一些基于平台的方法来获取这个标识符：</p><ul><li><p>Linux：线程的标识符类型是 <code>pthread_t</code>，可以使用 <code>pthread_self()</code>来获取。</p></li><li><p>在Windows平台上，线程的标识符类型是 <code>HANDLE</code>，可以使用 <code>GetCurrentThread()</code> 来获取。</p></li></ul><h2 id="thread-local" tabindex="-1"><a class="header-anchor" href="#thread-local"><span>thread_local</span></a></h2><p>这里补充一个关键字，<code>thread_local</code>：它用于声明线程局部变量，每个线程都有自己的副本，互不干扰。</p><p>对于 thread_local 修饰的变量，他会在线程首次访问时进行初始化，当线程退出时，该变量会被销毁，在实现一些缓存或者错误码管理时是比较有用的，如下是基本使用：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  thread_local</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> thread_local_var </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::jthread thr1{[</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]() -&gt; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    thread_local_var</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Thread 1, thread_local_var: {}</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, thread_local_var);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Main Thread, thread_local_var: {}</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, thread_local_var);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本节代码详见<a href="https://github.com/KBchulan/ClBlogs-Src/blob/main/blogs-main/concurrent/02-thread-control/main.cc" target="_blank" rel="noopener noreferrer">此处</a>。</p>`,44))])}const d=i(t,[["render",e]]),A=JSON.parse('{"path":"/blogs-main/concurrent/02-con.html","title":"02 线程管控","lang":"zh-CN","frontmatter":{"title":"02 线程管控","article":true,"order":2,"star":false,"category":["并发"],"tag":["cpp"],"date":"2025-08-08T00:00:00.000Z","description":"介绍线程归属权的管控、线程并发数量控制以及获取线程 id 等基本操作","footer":"Always coding, always learning","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"02 线程管控\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-11T14:55:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KBchulan\\",\\"url\\":\\"https://kbchulan.github.io/ClBlogs/\\"}]}"],["meta",{"property":"og:url","content":"https://kbchulan.github.io/ClBlogs/ClBlogs/blogs-main/concurrent/02-con.html"}],["meta",{"property":"og:site_name","content":"KBchulan的博客"}],["meta",{"property":"og:title","content":"02 线程管控"}],["meta",{"property":"og:description","content":"介绍线程归属权的管控、线程并发数量控制以及获取线程 id 等基本操作"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-11T14:55:53.000Z"}],["meta",{"property":"article:tag","content":"cpp"}],["meta",{"property":"article:published_time","content":"2025-08-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-11T14:55:53.000Z"}]]},"git":{"createdTime":1754641367000,"updatedTime":1754924153000,"contributors":[{"name":"KBchulan","username":"KBchulan","email":"145010602+KBchulan@users.noreply.github.com","commits":3,"url":"https://github.com/KBchulan"}]},"readingTime":{"minutes":5.37,"words":1610},"filePathRelative":"blogs-main/concurrent/02-con.md","excerpt":""}');export{d as comp,A as data};
